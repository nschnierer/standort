/*
 * Helper functions to use encryption with elliptic curve Diffie-Hellman (ECDH)
 * and AES-GCM algorithm.
 *
 * The following implementation is inspired by the following code:
 * https://github.com/mdn/dom-examples/blob/main/web-crypto/derive-key/ecdh.js
 *
 * IMPORTANT:
 * This code is being used for demonstration purposes only.
 * There is no guarantee that the encryption is secure.
 */

// Some parameters for key pair generation and encryption etc.
const KEY_PAIR_NAME = "ECDH";
const KEY_PAIR_CURVE = "P-256";
const KEY_PAIR_KEY_USAGE: KeyUsage[] = ["deriveKey"];
const EXPORT_FORMAT = "jwk";
const DERIVED_KEY_NAME = "AES-GCM";

/**
 * Generate a key pair with ECDH (elliptic curve Diffie-Hellman).
 * With the ability to derive a key.
 * @returns
 */
export const generateKeyPair = async () => {
  return window.crypto.subtle.generateKey(
    {
      name: KEY_PAIR_NAME,
      namedCurve: KEY_PAIR_CURVE,
    },
    true, // extractable
    KEY_PAIR_KEY_USAGE // key usage
  );
};

/**
 * Export a key to a JWK (JSON Web Key).
 */
export const exportKey = async (key: CryptoKey) => {
  return window.crypto.subtle.exportKey(EXPORT_FORMAT, key);
};

/**
 * Import a private key.
 */
export const importPrivateKey = async (key: JsonWebKey) => {
  return window.crypto.subtle.importKey(
    EXPORT_FORMAT,
    key,
    { name: KEY_PAIR_NAME, namedCurve: KEY_PAIR_CURVE },
    true, // extractable
    KEY_PAIR_KEY_USAGE
  );
};

/**
 * Import a public key.
 */
export const importPublicKey = async (key: JsonWebKey) => {
  return window.crypto.subtle.importKey(
    EXPORT_FORMAT,
    key,
    { name: KEY_PAIR_NAME, namedCurve: KEY_PAIR_CURVE },
    true, // extractable
    []
  );
};

/**
 * Derive a secret key from a private key and a public key.
 * @param privateKey Of the person who wants to encrypt the data.
 * @param publicKey Of the person who wants to decrypt the data.
 * @returns Secret key for encryption/decryption
 */
export const deriveSecretKey = async (
  privateKey: CryptoKey,
  publicKey: CryptoKey
) => {
  return window.crypto.subtle.deriveKey(
    {
      name: KEY_PAIR_NAME,
      public: publicKey,
    },
    privateKey,
    {
      name: DERIVED_KEY_NAME,
      length: 256,
    },
    true, // extractable
    ["encrypt", "decrypt"]
  );
};

/**
 * Encrypt data using AES-GCM algorithm.
 * @param secretKey Generated by `deriveSecretKey` function.
 * @returns Cipher text
 */
export const encrypt = async (secretKey: CryptoKey, data: string) => {
  // Initialization vector
  // Also known as nonce, it is a random value that is used only once.
  const iv = window.crypto.getRandomValues(new Uint8Array(12));
  const encoded = new TextEncoder().encode(data);
  const encrypted = await window.crypto.subtle.encrypt(
    {
      name: DERIVED_KEY_NAME,
      iv: iv,
    },
    secretKey,
    encoded
  );
  return {
    // There is no problem to send the iv to the server.
    iv: Array.from(iv),
    encrypted: Array.from(new Uint8Array(encrypted)),
  };
};

// Get the return type of encrypt function
export type EncryptedData = Awaited<ReturnType<typeof encrypt>>;

/**
 * Decrypt data using AES-GCM algorithm.
 * @param secretKey Generated by `deriveSecretKey` function.
 * @returns Plain text
 */
export const decrypt = async (secretKey: CryptoKey, data: EncryptedData) => {
  const iv = new Uint8Array(data.iv);
  const encrypted = new Uint8Array(data.encrypted);
  const decrypted = await window.crypto.subtle.decrypt(
    {
      name: DERIVED_KEY_NAME,
      iv,
    },
    secretKey,
    encrypted
  );
  return new TextDecoder().decode(decrypted);
};

/**
 * Converts an ArrayBuffer to a hex string.
 * @param buffer
 * @returns
 */
export const bufferToHex = (buffer: ArrayBuffer) => {
  return Array.from(new Uint8Array(buffer))
    .map((b) => b.toString(16).padStart(2, "0"))
    .join("");
};

/**
 * Generate a fingerprint from a public key.
 * @param publicKey
 * @returns SHA-256 hash of the public key.
 */
export const generateFingerprint = async (publicKey: JsonWebKey) => {
  // Just use the relevant parts of the JWK
  const { kty, x, y } = publicKey;
  const minimalPublicKey = { kty, x, y };

  // Use the SHA-256 hash algorithm over a stringified version of the public key.
  const buffer = await crypto.subtle.digest(
    "SHA-256",
    new TextEncoder().encode(JSON.stringify(minimalPublicKey))
  );
  return bufferToHex(buffer);
};

/**
 * Generate a SHA-256 checksum from a string.
 * @param data
 * @returns
 */
export const generateChecksum = async (data: string) => {
  const buffer = await crypto.subtle.digest(
    "SHA-256",
    new TextEncoder().encode(data)
  );
  return bufferToHex(buffer);
};
